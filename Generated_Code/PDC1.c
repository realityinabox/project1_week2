/* ###################################################################
 **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
 **     Filename    : PDC1.c
 **     Project     : Lab2
 **     Processor   : MK64FN1M0VLQ12
 **     Component   : PDC8544
 **     Version     : Component 01.003, Driver 01.00, CPU db: 3.00.000
 **     Compiler    : GNU C Compiler
 **     Date/Time   : 2015-01-12, 19:51, # CodeGen: 5
 **     Abstract    :
 **
 **     Settings    :
 **
 **     Contents    :
 **         GetWidth              - PDC1_PixelDim PDC1_GetWidth(void);
 **         GetHeight             - PDC1_PixelDim PDC1_GetHeight(void);
 **         GetLongerSide         - PDC1_PixelDim PDC1_GetLongerSide(void);
 **         GetShorterSide        - PDC1_PixelDim PDC1_GetShorterSide(void);
 **         SetDisplayOrientation - void PDC1_SetDisplayOrientation(PDC1_DisplayOrientation newOrientation);
 **         GetDisplayOrientation - PDC1_DisplayOrientation PDC1_GetDisplayOrientation(void);
 **         SetPos                - void PDC1_SetPos(PDC1_PixelDim x, PDC1_PixelDim y);
 **         Clear                 - void PDC1_Clear(void);
 **         ClearLine             - void PDC1_ClearLine(byte lineNumber);
 **         WriteChar             - void PDC1_WriteChar(char ch);
 **         WriteString           - void PDC1_WriteString(char *str);
 **         WriteLineStr          - void PDC1_WriteLineStr(byte line, char *str);
 **         SetContrast           - void PDC1_SetContrast(byte contrast);
 **         SetMode               - void PDC1_SetMode(bool inverted);
 **         UpdateFull            - void PDC1_UpdateFull(void);
 **         UpdateRegion          - void PDC1_UpdateRegion(PDC1_PixelDim x, PDC1_PixelDim y, PDC1_PixelDim w,...
 **         GetLCD                - void PDC1_GetLCD(void);
 **         GiveLCD               - void PDC1_GiveLCD(void);
 **         Init                  - void PDC1_Init(void);
 **         Deinit                - void PDC1_Deinit(void);
 **
 **     License : Open Source (LGPL)
 **     Copyright : (c) Copyright Erich Styger, 2014, all rights reserved.
 **     This an open source software in the form of a Processor Expert Embedded Component.
 **     This is a free software and is opened for education, research and commercial developments under license policy of following terms:
 **     * This is a free software and there is NO WARRANTY.
 **     * No restriction on use. You can use, modify and redistribute it for personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
 **     * Redistributions of source code must retain the above copyright notice.
 ** ###################################################################*/
/*!
 ** @file PDC1.c
 ** @version 01.00
 ** @brief
 **
 */
/*!
 **  @addtogroup PDC1_module PDC1 module documentation
 **  @{
 */

/* MODULE PDC1. */

#include "PDC1.h"

byte PDC1_DisplayBuf[((PDC1_DISPLAY_HW_NOF_ROWS-1)/8)+1][PDC1_DISPLAY_HW_NOF_COLUMNS]; /* buffer for the display */

static LDD_TDeviceData *RES_DeviceData; /* device handle for RES pin */
static LDD_TDeviceData *SCE_DeviceData; /* device handle for SCE pin */
static LDD_TDeviceData *D_C_DeviceData; /* device handle for D_C pin */

/* some aspects of the protocol are pretty timing sensitive... */
#define SET_SCE()   \
		WAIT1_Waitns(500); \
		SCEpin1_SetVal(SCE_DeviceData); /* set bit */ \
		WAIT1_Waitns(500);

#define CLR_SCE()   \
		WAIT1_Waitns(100); \
		SCEpin1_ClrVal(SCE_DeviceData); /* clr bit */ \
		WAIT1_Waitns(100);

#define CLR_D_C()   D_Cpin1_ClrVal(D_C_DeviceData) /* clr bit */
#define SET_D_C()   D_Cpin1_SetVal(D_C_DeviceData) /* set bit */

#define CLR_RES()   RESpin1_ClrVal(RES_DeviceData) /* clr bit */
#define SET_RES()   RESpin1_SetVal(RES_DeviceData) /* set bit */

static volatile bool PDC1_DataReceivedFlag = FALSE;

/* ASCII table for LCD: 96 rows * 5 bytes = 480 bytes
   Note that this is the same set of codes for character you
   would find on a HD44780 based character LCD.
   Also, given the size of the LCD (84 pixels by 48 pixels),
   the maximum number of characters per row is only 14. */
#define PDC1_FONT_COLUMNS_PER_CHAR   5 /* number of font data columns rows per character */
#define PDC1_FONT_ROWS_PER_CHAR      8 /* number of font data rows lines per character */
#define PDC1_SPACE_COLUMNS_PER_CHAR  1 /* number of space rows after a character */

#define PDC1_DOUBLE_FONT_COLUMNS_PER_CHAR   10 /* number of font data columns rows per character */
#define PDC1_DOUBLE_FONT_ROWS_PER_CHAR      16 /* number of font data rows lines per character */
#define PDC1_SPACE_COLUMNS_PER_DOUBLE_CHAR  2 /* number of space rows after a character */


#define PDC1_MAX_CHARS_PER_LINE      (PDC1_DISPLAY_HW_NOF_COLUMNS/(PDC1_FONT_COLUMNS_PER_CHAR+PDC1_SPACE_COLUMNS_PER_CHAR)) /* maximum number of character per line */
#define PDC1_MAX_LINES_FOR_DISPLAY   (PDC1_DISPLAY_HW_NOF_ROWS/PDC1_FONT_ROWS_PER_CHAR) /* maximum number of lines for the display */

//extern const unsigned char *pizza;
//extern const unsigned char *pizza_;

static const char table[480] =
{0x00,0x00,0x00,0x00,0x00, /* 20 space */
		0x00,0x00,0x5f,0x00,0x00, /* 21 ! */
		0x00,0x07,0x00,0x07,0x00, /* 22 " */
		0x14,0x7f,0x14,0x7f,0x14, /* 23 # */
		0x24,0x2a,0x7f,0x2a,0x12, /* 24 $ */
		0x23,0x13,0x08,0x64,0x62, /* 25 % */
		0x36,0x49,0x55,0x22,0x50, /* 26 & */
		0x00,0x05,0x03,0x00,0x00, /* 27 ' */
		0x00,0x1c,0x22,0x41,0x00, /* 28 ( */
		0x00,0x41,0x22,0x1c,0x00, /* 29 ) */
		0x14,0x08,0x3e,0x08,0x14, /* 2a * */
		0x08,0x08,0x3e,0x08,0x08, /* 2b + */
		0x00,0x50,0x30,0x00,0x00, /* 2c , */
		0x08,0x08,0x08,0x08,0x08, /* 2d - */
		0x00,0x60,0x60,0x00,0x00, /* 2e . */
		0x20,0x10,0x08,0x04,0x02, /* 2f / */
		0x3e,0x51,0x49,0x45,0x3e, /* 30 0 */
		0x00,0x42,0x7f,0x40,0x00, /* 31 1 */
		0x42,0x61,0x51,0x49,0x46, /* 32 2 */
		0x21,0x41,0x45,0x4b,0x31, /* 33 3 */
		0x18,0x14,0x12,0x7f,0x10, /* 34 4 */
		0x27,0x45,0x45,0x45,0x39, /* 35 5 */
		0x3c,0x4a,0x49,0x49,0x30, /* 36 6 */
		0x01,0x71,0x09,0x05,0x03, /* 37 7 */
		0x36,0x49,0x49,0x49,0x36, /* 38 8 */
		0x06,0x49,0x49,0x29,0x1e, /* 39 9 */
		0x00,0x36,0x36,0x00,0x00, /* 3a : */
		0x00,0x56,0x36,0x00,0x00, /* 3b ; */
		0x08,0x14,0x22,0x41,0x00, /* 3c < */
		0x14,0x14,0x14,0x14,0x14, /* 3d = */
		0x00,0x41,0x22,0x14,0x08, /* 3e > */
		0x02,0x01,0x51,0x09,0x06, /* 3f ? */
		0x32,0x49,0x79,0x41,0x3e, /* 40 @ */
		0x7e,0x11,0x11,0x11,0x7e, /* 41 A */
		0x7f,0x49,0x49,0x49,0x36, /* 42 B */
		0x3e,0x41,0x41,0x41,0x22, /* 43 C */
		0x7f,0x41,0x41,0x22,0x1c, /* 44 D */
		0x7f,0x49,0x49,0x49,0x41, /* 45 E */
		0x7f,0x09,0x09,0x09,0x01, /* 46 F */
		0x3e,0x41,0x49,0x49,0x7a, /* 47 G */
		0x7f,0x08,0x08,0x08,0x7f, /* 48 H */
		0x00,0x41,0x7f,0x41,0x00, /* 49 I */
		0x20,0x40,0x41,0x3f,0x01, /* 4a J */
		0x7f,0x08,0x14,0x22,0x41, /* 4b K */
		0x7f,0x40,0x40,0x40,0x40, /* 4c L */
		0x7f,0x02,0x0c,0x02,0x7f, /* 4d M */
		0x7f,0x04,0x08,0x10,0x7f, /* 4e N */
		0x3e,0x41,0x41,0x41,0x3e, /* 4f O */
		0x7f,0x09,0x09,0x09,0x06, /* 50 P */
		0x3e,0x41,0x51,0x21,0x5e, /* 51 Q */
		0x7f,0x09,0x19,0x29,0x46, /* 52 R */
		0x46,0x49,0x49,0x49,0x31, /* 53 S */
		0x01,0x01,0x7f,0x01,0x01, /* 54 T */
		0x3f,0x40,0x40,0x40,0x3f, /* 55 U */
		0x1f,0x20,0x40,0x20,0x1f, /* 56 V */
		0x3f,0x40,0x38,0x40,0x3f, /* 57 W */
		0x63,0x14,0x08,0x14,0x63, /* 58 X */
		0x07,0x08,0x70,0x08,0x07, /* 59 Y */
		0x61,0x51,0x49,0x45,0x43, /* 5a Z */
		0x00,0x7f,0x41,0x41,0x00, /* 5b [ */
		0x02,0x04,0x08,0x10,0x20, /* 5c Yen Currency Sign */
		0x00,0x41,0x41,0x7f,0x00, /* 5d ] */
		0x04,0x02,0x01,0x02,0x04, /* 5e ^ */
		0x40,0x40,0x40,0x40,0x40, /* 5f _ */
		0x00,0x01,0x02,0x04,0x00, /* 60 ` */
		0x20,0x54,0x54,0x54,0x78, /* 61 a */
		0x7f,0x48,0x44,0x44,0x38, /* 62 b */
		0x38,0x44,0x44,0x44,0x20, /* 63 c */
		0x38,0x44,0x44,0x48,0x7f, /* 64 d */
		0x38,0x54,0x54,0x54,0x18, /* 65 e */
		0x08,0x7e,0x09,0x01,0x02, /* 66 f */
		0x0c,0x52,0x52,0x52,0x3e, /* 67 g */
		0x7f,0x08,0x04,0x04,0x78, /* 68 h */
		0x00,0x44,0x7d,0x40,0x00, /* 69 i */
		0x20,0x40,0x44,0x3d,0x00, /* 6a j */
		0x7f,0x10,0x28,0x44,0x00, /* 6b k */
		0x00,0x41,0x7f,0x40,0x00, /* 6c l */
		0x7c,0x04,0x18,0x04,0x78, /* 6d m */
		0x7c,0x08,0x04,0x04,0x78, /* 6e n */
		0x38,0x44,0x44,0x44,0x38, /* 6f o */
		0x7c,0x14,0x14,0x14,0x08, /* 70 p */
		0x08,0x14,0x14,0x18,0x7c, /* 71 q */
		0x7c,0x08,0x04,0x04,0x08, /* 72 r */
		0x48,0x54,0x54,0x54,0x20, /* 73 s */
		0x04,0x3f,0x44,0x40,0x20, /* 74 t */
		0x3c,0x40,0x40,0x20,0x7c, /* 75 u */
		0x1c,0x20,0x40,0x20,0x1c, /* 76 v */
		0x3c,0x40,0x30,0x40,0x3c, /* 77 w */
		0x44,0x28,0x10,0x28,0x44, /* 78 x */
		0x0c,0x50,0x50,0x50,0x3c, /* 79 y */
		0x44,0x64,0x54,0x4c,0x44, /* 7a z */
		0x00,0x08,0x36,0x41,0x00, /* 7b < */
		0x00,0x00,0x7f,0x00,0x00, /* 7c | */
		0x00,0x41,0x36,0x08,0x00, /* 7d > */
		0x10,0x08,0x08,0x10,0x08, /* 7e Right Arrow -> */
		0x78,0x46,0x41,0x46,0x78};/* 7f Left Arrow  <- */


/* Internal method prototypes */


/*
 ** ===================================================================
 **     Method      :  WriteCmd (component PDC8544)
 **
 **     Description :
 **         Writes a command to the display
 **         This method is internal. It is used by Processor Expert only.
 ** ===================================================================
 */
void WriteCmd(byte cmd)
{
	uint8_t dummy;

	CLR_D_C();                           /* D_C low: select command mode */
	CLR_SCE();                           /* SCE low: select device */
	PDC1_DataReceivedFlag = FALSE;
	SM1_ReceiveBlock(SM1_DeviceData, &dummy, 1);
	SM1_SendBlock(SM1_DeviceData, &cmd, 1);
	while (!PDC1_DataReceivedFlag) {};                            /* Wait until data block is transmitted/received */
	SET_SCE();                           /* CE high: deselect device */
}

/*
 ** ===================================================================
 **     Method      :  WriteData (component PDC8544)
 **
 **     Description :
 **         Write a data byte to the display
 **         This method is internal. It is used by Processor Expert only.
 ** ===================================================================
 */
void WriteData(byte data)
{
	uint8_t dummy;

	SET_D_C();                           /* D_C high: select data mode */
	CLR_SCE();                           /* SCE low: select device */
	PDC1_DataReceivedFlag = FALSE;
	SM1_ReceiveBlock(SM1_DeviceData, &dummy, 1);
	SM1_SendBlock(SM1_DeviceData, &data, 1);
	while (!PDC1_DataReceivedFlag) {};                            /* Wait until data block is transmitted/received */
	SET_SCE();                           /* CE high: deselect device */
}

/*
 ** ===================================================================
 **     Method      :  PDC1_SetPos (component PDC8544)
 **     Description :
 **         Sets the cursor to the given position
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **         x               - The column number (in bits). In the range
 **                           of 0...83.
 **         y               - The row number (byte rows), in the range of
 **                           0..5.
 **     Returns     : Nothing
 ** ===================================================================
 */
void PDC1_SetPos(PDC1_PixelDim x, PDC1_PixelDim y)
{
	WriteCmd((byte)(0x40|(y&0x07)));      /* Y axis */
	//  WriteCmd((byte)(0x80|(x&(PDC1_DISPLAY_HW_NOF_COLUMNS-1)))); /* X axis */
	WriteCmd((byte)(0x80|(x&(0x7f))));
}

/*
 ** ===================================================================
 **     Method      :  PDC1_Clear (component PDC8544)
 **     Description :
 **         Clears the whole display memory.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
void PDC1_Clear(void)
{
	short ddram;

	PDC1_SetPos(0, 0);                    /* move cursor to beginning of line */
	for (ddram=PDC1_DISPLAY_HW_NOF_COLUMNS*(PDC1_DISPLAY_HW_NOF_ROWS/8); ddram>0; ddram--) {
		WriteData(0);                       /* clear actual line */
	}
}

/*
 ** ===================================================================
 **     Method      :  PDC1_ClearLine (component PDC8544)
 **     Description :
 **         Clears a character line on the display
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **         lineNumber      - the line number of the line
 **                           to be cleared.
 **     Returns     : Nothing
 ** ===================================================================
 */
void PDC1_ClearLine(byte lineNumber)
{
	byte ddram;

	PDC1_SetPos(0, (PDC1_PixelDim)lineNumber); /* move cursor to beginning of line */
	for (ddram=PDC1_DISPLAY_HW_NOF_COLUMNS; ddram>0; ddram--) {
		WriteData(0);                       /* clear actual line */
	}
	PDC1_SetPos(0,0);                     /* move cursor home */
}

/*
 ** ===================================================================
 **     Method      :  PDC1_Init (component PDC8544)
 **     Description :
 **         Display driver initialization
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
void PDC1_Init(void)
{
	int i = 0;
	RES_DeviceData = RESpin1_Init(NULL); /* device handle for RES pin */
	SCE_DeviceData = SCEpin1_Init(NULL); /* device handle for SCE pin */
	D_C_DeviceData = D_Cpin1_Init(NULL); /* device handle for D_C pin */
	/* boot display */
	SET_RES();                            /* RES high: start reset sequence */
	SET_SCE();                            /* CS high: Disable device */
	WAIT1_Waitms(10);                     /* wait at least 10ms */
	CLR_RES();                            /* Reset line low */
	WAIT1_Waitms(100);                    /* wait at least 100ms */
	SET_RES();                            /* Awake LCD from RESET state. */

	/* initialize display */
	WriteCmd(0x21);                       /* Activate Chip and H=1 */
	WriteCmd(0xC8);                       /* Set LCD Voltage; Vop v1: 0xc8 (for 3V), v2: 0xa0 (for 3V), v3: 0xc2 (2.6V-5V) */
	WriteCmd(0x13);                       /* Adjust voltage bias */
	WriteCmd(0x20);                       /* Horizontal addressing and H=0  0x20 is horizontal, 0x22 is vertical*/
	WriteCmd(0x09);                       /* Activate all segments */
	PDC1_Clear();                         /* Erase all pixel on the DDRAM */
	WriteCmd(0x08);                       /* Blank the Display */
	WriteCmd(0x0C);                       /* Normal display mode */

	PDC1_SetContrast(80);
	PDC1_SetPos(0,0);                     /* Cursor Home */

	PDC1_Splash();

	PDC1_Clear();							/* Erase screen */
	PDC1_SetPos(0,0); 					/* Reset to home position */
}


/*
 ** ===================================================================
 **     Method      :  PDC1_WriteChar (component PDC8544)
 **     Description :
 **         Writes a single character to the display at the current
 **         position.
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **         ch              - Char to be written to the display.
 **     Returns     : Nothing
 ** ===================================================================
 */
void PDC1_WriteChar(char ch)
{
	int tablept = 0;
	int count = 0;
	int char_column = 0;

	if ((ch<0x20)||(ch>0x7f)) {          /* check for valid character */
		return;
	}
	tablept = (PDC1_FONT_COLUMNS_PER_CHAR*((int)ch))-160; /* find character bitmap */
	for (count=PDC1_FONT_COLUMNS_PER_CHAR;count>0;count--) { /* draw the columns to print the character */
		char_column = table[tablept];
		WriteData((byte)char_column);
		tablept++;
	}
	for(count=PDC1_SPACE_COLUMNS_PER_CHAR;count>0;count--) {
		WriteData(0x00);                   /* create 1-pixel spacing per character */
	}
}

/*
 ** ===================================================================
 **     Method      :  PDC1_WriteString (component PDC8544)
 **     Description :
 **         Writes a zero byte terminated string to the display at the
 **         current cursor position.
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **       * str             - Pointer to string to be written to the
 **                           display.
 **     Returns     : Nothing
 ** ===================================================================
 */
void PDC1_WriteString(char *str)
{
	while(*str != '\0') {
		PDC1_WriteChar(*(str++));          /*Points to one ASCII to be written one at a time */
	}
}

/*
 ** ===================================================================
 **     Method      :  PDC1_WriteLineStr (component PDC8544)
 **     Description :
 **         Writes a string to the given line position.
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **         line            - The line number, starting with 1.
 **       * str             - Pointer to zero byte terminated string
 **     Returns     : Nothing
 ** ===================================================================
 */
void PDC1_WriteLineStr(byte line, char *str)
{
	byte i;

	if (line==0 || line>PDC1_MAX_LINES_FOR_DISPLAY) {
		return; /* invalid line number */
	}
	PDC1_SetPos(0, (PDC1_PixelDim)(line-1));
	for(i=0; i<PDC1_MAX_CHARS_PER_LINE && *str != '\0'; i++) { /* only write as much characters as there is space on the line */
		PDC1_WriteChar(*(str++));          /* write character */
	}
}

/*
 ** ===================================================================
 **     Method      :  PDC1_UpdateRegion (component PDC8544)
 **     Description :
 **         Updates a region of the display
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **         x               - x coordinate
 **         y               - y coordinate
 **         w               - width of the region
 **         h               - height of the region
 **     Returns     : Nothing
 ** ===================================================================
 */
void PDC1_UpdateRegion(PDC1_PixelDim x, PDC1_PixelDim y, PDC1_PixelDim w, PDC1_PixelDim h)
{
	(void)x; (void)y; (void)w; (void)h;
	PDC1_UpdateFull();                    /* NYI, we simply refresh everything :-( */
}

/*
 ** ===================================================================
 **     Method      :  PDC1_UpdateFull (component PDC8544)
 **     Description :
 **         Updates the whole display
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
void PDC1_UpdateFull(void)
{
	word numBytes = sizeof(PDC1_DisplayBuf);
	byte *data = (byte*)PDC1_DisplayBuf;

	PDC1_SetPos(0, 0);                    /* move cursor to beginning of display */
	while(numBytes>0) {
		WriteData(*data++);                 /* write data */
		numBytes--;
	}
}

/*
 ** ===================================================================
 **     Method      :  PDC1_SetContrast (component PDC8544)
 **     Description :
 **         Sets the display contrast.
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **         contrast        - Contrast value, must be in the
 **                           range of  0 >= x < 128
 **     Returns     : Nothing
 ** ===================================================================
 */
void PDC1_SetContrast(byte contrast)
{
	if (contrast < 128) { /* check for valid contrast values */
		WriteCmd(0x21);
		WriteCmd((byte)(0x80|contrast));
		WriteCmd(0x20);
	}
}

/*
 ** ===================================================================
 **     Method      :  PDC1_SetMode (component PDC8544)
 **     Description :
 **         Sets the mode of the display (if inverted or not).
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **         inverted        - Pass TRUE to have the display
 **                           operate in inverted mode, FALSE for normal
 **                           mode.
 **     Returns     : Nothing
 ** ===================================================================
 */
void PDC1_SetMode(bool inverted)
{
	if (inverted) {
		WriteCmd(0x0C|1);                   /* Inverted display mode */
	} else {
		WriteCmd(0x0C);                     /* Normal display mode */
	}
}

/*
 ** ===================================================================
 **     Method      :  PDC1_GetDisplayOrientation (component PDC8544)
 **     Description :
 **         Returns the current display orientation
 **     Parameters  : None
 **     Returns     :
 **         ---             - current display orientation
 ** ===================================================================
 */
PDC1_DisplayOrientation PDC1_GetDisplayOrientation(void)
{
	return PDC1_ORIENTATION_LANDSCAPE;   /* Landscape mode */
}

/*
 ** ===================================================================
 **     Method      :  PDC1_GetWidth (component PDC8544)
 **     Description :
 **         Returns the width of the display in pixels
 **     Parameters  : None
 **     Returns     :
 **         ---             - width of display
 ** ===================================================================
 */
/*
PDC1_PixelDim PDC1_GetWidth(void)
{
 *** Method is implemented as macro in PDC1.h
}
 */

/*
 ** ===================================================================
 **     Method      :  PDC1_GetHeight (component PDC8544)
 **     Description :
 **         Returns the height of the display in pixels
 **     Parameters  : None
 **     Returns     :
 **         ---             - height of display
 ** ===================================================================
 */
/*
PDC1_PixelDim PDC1_GetHeight(void)
{
 *** Method is implemented as macro in PDC1.h
}
 */

/*
 ** ===================================================================
 **     Method      :  PDC1_GetLongerSide (component PDC8544)
 **     Description :
 **         Returns the longer side of the display in pixels
 **     Parameters  : None
 **     Returns     :
 **         ---             - longer side of display
 ** ===================================================================
 */
/*
PDC1_PixelDim PDC1_GetLongerSide(void)
{
 *** Method is implemented as macro in PDC1.h
}
 */

/*
 ** ===================================================================
 **     Method      :  PDC1_GetShorterSide (component PDC8544)
 **     Description :
 **         Returns the shorter side of the display in pixels
 **     Parameters  : None
 **     Returns     :
 **         ---             - shorter side of display
 ** ===================================================================
 */
/*
PDC1_PixelDim PDC1_GetShorterSide(void)
{
 *** Method is implemented as macro in PDC1.h
}
 */

/*
 ** ===================================================================
 **     Method      :  PDC1_SetDisplayOrientation (component PDC8544)
 **     Description :
 **         Sets current display orientation
 **     Parameters  :
 **         NAME            - DESCRIPTION
 **         newOrientation  - the new orientation
 **                           for the display
 **     Returns     : Nothing
 ** ===================================================================
 */
void PDC1_SetDisplayOrientation(PDC1_DisplayOrientation newOrientation)
{
	(void)newOrientation; /* setting the display orientation is not implemented yet */
}

/*
 ** ===================================================================
 **     Method      :  PDC1_GetLCD (component PDC8544)
 **     Description :
 **         Method to be called for mutual exclusive access to the LCD
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
void PDC1_GetLCD(void)
{
	/* If you see this comment in generated code, it means that method is not implemented yet ... */
}

/*
 ** ===================================================================
 **     Method      :  PDC1_GiveLCD (component PDC8544)
 **     Description :
 **         Method to be called for mutual exclusive access to the LCD
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
void PDC1_GiveLCD(void)
{
	/* If you see this comment in generated code, it means that method is not implemented yet ... */
}

/*
 ** ===================================================================
 **     Method      :  PDC1_OnBlockReceived (component PDC8544)
 **
 **     Description :
 **         This method is internal. It is used by Processor Expert only.
 ** ===================================================================
 */
void SM1_OnBlockReceived(LDD_TUserData *UserDataPtr)
{
	PDC1_DataReceivedFlag = TRUE;
	/* Calling inherited event */
}

/*
 ** ===================================================================
 **     Method      :  PDC1_Deinit (component PDC8544)
 **     Description :
 **         Module Deinitialization
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
void PDC1_Deinit(void)
{
	RESpin1_Deinit(RES_DeviceData); /* device handle for RES pin */
	SCEpin1_Deinit(SCE_DeviceData); /* device handle for SCE pin */
	D_Cpin1_Deinit(D_C_DeviceData); /* device handle for D_C pin */
}

/*
 ** ===================================================================
 **     Method      :  PDC1_Splash (component PDC8544)
 **     Description :
 **         Splash screen animation for LCD
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */

void PDC1_Splash(void){
	int i = 0;
	PDC1_image();					/* Display splash image*/
	WAIT1_Waitms(100);					/* Wait 1s*/
	while(i<5){
		WriteCmd(0x0D);                       /* Inverted display mode */
		if (i == 1){
			PDC1_WriteStringBigger("Pizza", 3, 2);
			WAIT1_Waitms(100);					/* Wait 100ms*/
		}
		else{
			PDC1_image();					/* Display splash image*/
			WAIT1_Waitms(100);					/* Wait 1ms*/

		}
		WriteCmd(0x0C);                       /* Normal display mode */
		if (i == 3){
			PDC1_WriteStringBigger("John!", 3, 2);		/* Wait 1s*/
			WAIT1_Waitms(100);					/* Wait 100ms*/
		}
		else{
			PDC1_image();					/* Display splash image*/
			WAIT1_Waitms(100);					/* Wait 100ms*/
		}
		i++;
	}

	PDC1_SetPos(0,0);
	WAIT1_Waitms(200);
}

/*
 ** ===================================================================
 **     Method      :  PDC1_image (component PDC8544)
 **     Description :
 **         Splash screen animation for LCD
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
void PDC1_image(void)
{

	int count = 0;
	int char_col = 0;
	// int table_pt = *xkcd_image;
	int length = 498;

	// char array containing image information
	const unsigned char pizza_test [] = {
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x0F, 0x07, 0x07,
			0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
			0x07, 0x07, 0x07, 0x07, 0x07, 0x0F, 0x1F, 0x1F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0,
			0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x90, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x0F,
			0x0F, 0xFF, 0x30, 0x10, 0x00, 0x09, 0x19, 0x0D, 0x4D, 0x1F, 0x1F, 0x0F, 0x0F, 0x0C, 0x08, 0xF0,
			0x20, 0x00, 0x00, 0x70, 0xF0, 0x18, 0x4C, 0x9E, 0xBF, 0x9F, 0xCF, 0xF9, 0x39, 0x39, 0xFF, 0x7F,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFE, 0xE0, 0xE0, 0xE1, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x80, 0xFF, 0xC0, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xE0, 0x80, 0x00, 0x00, 0x00, 0x20, 0x38,
			0x38, 0x18, 0x38, 0x3C, 0x3C, 0x3E, 0x25, 0x25, 0x25, 0x27, 0x7D, 0x78, 0x38, 0x38, 0x78, 0xE0,
			0xE0, 0xF0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC,
			0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0xC0, 0xC0, 0xE0, 0x80, 0xC0, 0xC0, 0xE0, 0xF0, 0xF0,
			0xF8, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	};

	// determine the length of the array for looping
	length = sizeof(pizza_test);

	// set to home position
	PDC1_SetPos(0,0);
	//loop through the char array and write each byte to the display
	for (count=0; count<length; count++) {
		char_col = pizza_test[count];
		WriteData((byte)char_col);
	}
}

#define NIGHT 3
#define CLOUDY 2
#define SUNNY  1

void PDC1_weather_image(int type, int x, int y){

	int char_col = 0;
	int count = 0;
	int tablept = 0;
	const unsigned char sunny[] = {
			0x00, 0x00, 0x00, 0x10, 0x38, 0x70, 0x20, 0x00, 0x80, 0xC0, 0xC0, 0xCE, 0xCE, 0xC0, 0xC0, 0x80,
			0x00, 0x20, 0x70, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x7E, 0xFF,
			0x83, 0x81, 0x00, 0x00, 0x00, 0x00, 0x81, 0xC3, 0xFF, 0x7E, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18,
			0x00, 0x00, 0x00, 0x08, 0x1C, 0x0E, 0x04, 0x00, 0x01, 0x03, 0x03, 0x73, 0x73, 0x03, 0x03, 0x01,
			0x00, 0x04, 0x0E, 0x1C, 0x08, 0x00, 0x00, 0x00,
	};
	const unsigned char night[] = {
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0x60, 0xE0, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E,
			0x63, 0x80, 0x00, 0x07, 0x0C, 0x18, 0x10, 0x20, 0x20, 0xA0, 0xE0, 0x60, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x02, 0x02, 0x02, 0x03,
			0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	};
	const unsigned char cloudy[] = {
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0x40, 0x60, 0x20, 0x20, 0x20, 0x20, 0x60, 0x40,
			0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x46, 0x83, 0x01, 0x01, 0x01, 0x80,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x01, 0x03, 0x83, 0xC6, 0x7C, 0x00,
			0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x02, 0x01, 0x03, 0x02, 0x06, 0x04, 0x04, 0x04, 0x06, 0x03,
			0x01, 0x03, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00,
	};

	if (type == SUNNY){
		PDC1_SetPos(x,y);  //Set the position
		// Loop through the string to write it out
		for (count=0; count<72; count++) {
			char_col = *(sunny + count);  // get first byte of display column
			WriteData((byte)char_col);     //write first byte
			if ((count + 1) % 24 == 0){
				y++;						// move to next display column
				PDC1_SetPos(x, y);
			}
		}
	}
	if (type == CLOUDY){
		PDC1_SetPos(x,y);  //Set the position
		// Loop through the string to write it out
		for (count=0; count<72; count++) {
			char_col = *(cloudy + count);  // get first byte of display column
			WriteData((byte)char_col);     //write first byte
			if ((count + 1) % 24 == 0){
				y++;						// move to next display column
				PDC1_SetPos(x, y);
			}
		}
	}
	if (type == NIGHT){
		PDC1_SetPos(x,y);  //Set the position
		// Loop through the string to write it out
		for (count=0; count<72; count++) {
			char_col = *(night + count);  // get first byte of display column
			WriteData((byte)char_col);     //write first byte
			if ((count + 1) % 24 == 0){
				y++;						// move to next display column
				PDC1_SetPos(x, y);
			}
		}
	}
}

/*
 ** ===================================================================
 **     Method      :  DoubleNibble (component PDC8544)
 **     Description :
 **         Takes a nibble of a byte and returns a "doubled" version
 **         ex) 0101 becomes 00110011
 **     Parameters  : int nib, the nibble to be doubled
 **     Returns     : the newly doubled nibble
 ** ===================================================================
 */

int DoubleNibble(int nib){

	// Finds the current case and returns the appropriate byte
	switch (nib){
	case 0x0:
		return 0x00;
	case 0x1:
		return 0x03;
	case 0x2:
		return 0x0c;
	case 0x3:
		return 0x0f;
	case 0x4:
		return 0x30;
	case 0x5:
		return 0x33;
	case 0x6:
		return 0x3c;
	case 0x7:
		return 0x3f;
	case 0x8:
		return 0xc0;
	case 0x9:
		return 0xc3;
	case 0xa:
		return 0xcc;
	case 0xb:
		return 0xcf;
	case 0xc:
		return 0xf0;
	case 0xd:
		return 0xf3;
	case 0xe:
		return 0xfc;
	case 0xf:
		return 0xff;
	}
}

/*
 ** ===================================================================
 **     Method      :  PDC1_MakeCharBigger (component PDC8544)
 **     Description :
 **         Finds the normal size character array and doubles it
 **     Parameters  :
 **     		char c: character to be written
 **     Returns     : array containing 2x sized character array
 ** ===================================================================
 */
int * PDC1_MakeCharBigger(char ch)
{
	int tablept = 0;
	int count = 0;
	int i = 0, j = 0;
	int char_column[5];
	int lsb_nibble = 0;
	int msb_nibble = 0;
	int lsb = 0, msb = 0;
	static int bigger[20];

	if ((ch<0x20)||(ch>0x7f)) {          /* check for valid character */
		return 0;
	}
	tablept = (PDC1_FONT_COLUMNS_PER_CHAR*((int)ch))-160; /* find character bitmap */
	for (i=PDC1_FONT_COLUMNS_PER_CHAR;i>0;i--) { /* copy the char array into char_column array */
		char_column[j] = table[tablept];
		j++;
		tablept++;
	}
	j = 0;
	// array will have 5 bytes, need to loop through each byte
	for (i = 0; i<5; i++){
		// mask the first nibble off
		lsb_nibble = (0x0f&char_column[i]);
		// mask second nibble off
		msb_nibble = (0xf0&char_column[i]);
		// turn first nibble into byte
		lsb = DoubleNibble(lsb_nibble);
		// turn second nibble into byte, left shift 4 to get rid of the 4 lsb zeros
		msb = DoubleNibble(msb_nibble>>4);
		// concatenate the two bytes onto the new array
		bigger[j] = lsb;
		bigger[j+1] = msb;
		bigger[j+2] = lsb;
		bigger[j+3] = msb;
		j+=4;
	}
	// return new array
	return bigger;
}
/*
 ** ===================================================================
 **     Method      :  PDC1_WriteCharBigger (component PDC8544)
 **     Description :
 **         Outputs a character at 2x font size
 **     Parameters  :
 **     		char c: character to be written
 **     		int x: x position to start
 **     		int y: y position to start
 **     Returns     : new x position
 ** ===================================================================
 */
int PDC1_WriteCharBigger(char ch, int x, int y)
{
	int char_col = 0;
	int count = 0;
	int tablept = 0;
	int *bigger = PDC1_MakeCharBigger(ch);

	WriteCmd(0x22);   /* set vertical addressing*/

	PDC1_SetPos(x,y);  //Set the position

	// Loop through the string to write it out
	for (count=0; count<20; count++) {

		char_col = *(bigger + count);  // get first byte of display column
		WriteData((byte)char_col);     //write first byte

		if ((count + 1) % 2 == 0){
			x++;						// move to next display column
			PDC1_SetPos(x, y);
		}
	}

	// add 2 columns of space after character
	for(count=PDC1_SPACE_COLUMNS_PER_DOUBLE_CHAR;count>0;count--) {
		WriteData(0x00);
		WriteData(0x00);
		x++;
		PDC1_SetPos(x, y);
	}

	WriteCmd(0x20);   /* set back to horizontal addressing*/

	// return new x position (y should be the same as original y value)
	return x;
}
/*
 ** ===================================================================
 **     Method      :  PDC1_WriteStringBigger (component PDC8544)
 **     Description :
 **         Outputs a string at 2x font size
 **     Parameters  :
 **     		int *str: string to be written
 **     		int len: length of string
 **     		int x: x position to start
 **     		int y: y position to start
 **     Returns     : new x position
 ** ===================================================================
 */

int PDC1_WriteStringBigger(char *str, int x, int y)
{
	while(*str != '\0') {
		x = PDC1_WriteCharBigger(*(str++), x ,y);          /*Points to one ASCII to be written one at a time */
	}
	return x;
}





/* END PDC1. */

/*!
 ** @}
 */
/*
 ** ###################################################################
 **
 **     This file was created by Processor Expert 10.4 [05.11]
 **     for the Freescale Kinetis series of microcontrollers.
 **
 ** ###################################################################
 */
